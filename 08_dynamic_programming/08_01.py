# import : built-ins


def get_minimum_number_of_operations(n):
    """
    [유형 : DP]
    주어진 숫자 n 에 대해 다음과 같은 연산을 반복 수행하여 1 을 만들고자 하는데,
    이 때 필요한 최소한의 연산만 적용하여 1 읆 만들려면, 최소 몇 번 이상 해야 할까?

    * 방법 1. n 에서 1 을 뺀다.
    * 방법 2. n 이 2 로 나누어 떨어지면, 2 로 나눌 수 있다.
    * 방법 3. n 이 3 로 나누어 떨어지면, 3 로 나눌 수 있다.
    * 방법 4. n 이 5 로 나누어 떨어지면, 5 로 나눌 수 있다.

    >>> get_minimum_number_of_operations(26)
    3

    :param n: 1 로 만들어야 하는 숫자
    :type n: int
    :return: 1 로 만들기까지 소요된 최소 연산 횟수
    :rtype: int
    """

    # 결과값을 저장할 배열을 초기화합니다.
    d = (n + 1) * [0]

    # 2 원부터 출발하여 n 원까지 순차적으로 조사합니다.
    # 아이디어 : (2 원을 1 원으로 만드는 최소 연산 횟수) + 1 = (3 원을 1 원으로 만드는 최소 연산 횟수)
    for i in range(2, len(d)):  # i 원을 1 원으로 만들기 위해 필요한 최소 연산 횟수를 구합니다.

        # 가장 감소 폭이 적은 연산부터 크게 줄이는 연산 순으로 적용 여부를 테스트해 봅니다.

        # 1. 일단 현재 i 에 1 을 감소시키는 연산을 적용할 경우 필요한 최소 연산 횟수는
        #   - ((i - 1) 을 1 로 만드는 데 필요한 최소 연산 횟수) + 1 이 됩니다.
        d[i] = d[i - 1] + 1

        # 2. 만약 현재 i 가 2 로 나눠 떨어진다면 필요한 최소 연산 횟수는
        #   - ((i // 2) 를 1 로 만드는 데 필요한 최소 연산 횟수) + 1
        #   - 앞에서 도출된 d[i] : 방법 1 채택 시 필요한 최소 연산 횟수
        # 둘 중 작은 쪽을 채택합니다.
        if i % 2 == 0:
            d[i] = min(d[i], d[i // 2] + 1)

        # 3. 만약 현재 i 가 3 로 나눠 떨어진다면 필요한 최소 연산 횟수는
        #   - ((i // 3) 를 1 로 만드는 데 필요한 최소 연산 횟수) + 1
        #   - 앞에서 도출된 d[i] : 방법 1 또는 방법 2 채택 시 필요한 최소 연산 횟수
        # 둘 중 작은 쪽을 채택합니다.
        if i % 3 == 0:
            d[i] = min(d[i], d[i // 3] + 1)

        # 4. 만약 현재 i 가 5 로 나눠 떨어진다면 필요한 최소 연산 횟수는
        #   - ((i // 5) 를 1 로 만드는 데 필요한 최소 연산 횟수) + 1
        #   - 앞에서 도출된 d[i] : 방법 1 또는 방법 2 또는 방법 3 채택 시 필요한 최소 연산 횟수
        # 둘 중 작은 쪽을 채택합니다.
        if i % 5 == 0:
            d[i] = min(d[i], d[i // 5] + 1)

    # 결과 값을 반환합니다.
    return d[-1]


if __name__ == '__main__':
    import doctest
    doctest.testmod(verbose=True)
